name: Deploy Blog

on:
  push:
    branches: [main]
  release:
    types: [published]

jobs:
  deploy:
    # Split out staging/dev later.
    environment: ${{ github.event_name == 'release' && 'production' || 'dev' }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: recursive
    

    
    # Force submodule initialization if needed
    - name: Initialize and update submodules
      run: |
        echo "=== Initializing submodules ==="
        git submodule init
        git submodule update --recursive
        echo "=== Post-update submodule status ==="
        git submodule status
        echo "=== Themes directory after update ==="
        ls -la themes/ || echo "Still no themes directory"

        # Debug submodule status
    - name: Debug submodule status
      run: |
        echo "=== Git submodule status ==="
        git submodule status
        echo "=== Checking for submodule directories ==="
        find . -name ".gitmodules" -exec cat {} \;
        echo "=== Directory listing ==="
        ls -la
        echo "=== Themes directory ==="
        ls -la themes/ || echo "No themes directory"
    
    # Initial AWS auth (using OIDC with a basic role)
    - name: Configure initial AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_PARAMETER_ROLE_ARN }}
        aws-region: us-east-2

  
        # Test AWS CLI availability
    - name: Test AWS CLI 0
      run: |
        which aws
        aws --version
        aws sts get-caller-identity
    
    # Pull config from Parameter Store (including the main role ARN)
    - name: Get configuration from Parameter Store
      run: |
        BLOG_ROLE_ARN=$(aws ssm get-parameter --name "/blog/${{ vars.ENVIRONMENT }}/deployment/github-actions-role-arn" --query "Parameter.Value" --output text)
        BLOG_BUCKET=$(aws ssm get-parameter --name "/blog/${{ vars.ENVIRONMENT }}/content/bucket-name" --query "Parameter.Value" --output text)
        CLOUDFRONT_ID=$(aws ssm get-parameter --name "/blog/${{ vars.ENVIRONMENT }}/content/cloudfront-distribution-id" --query "Parameter.Value" --output text)
        DOMAIN_NAME=$(aws ssm get-parameter --name "/blog/${{ vars.ENVIRONMENT }}/content/website-url" --query "Parameter.Value" --output text)

        echo "BLOG_ROLE_ARN=$BLOG_ROLE_ARN" >> $GITHUB_ENV
        echo "BLOG_BUCKET=$BLOG_BUCKET" >> $GITHUB_ENV
        echo "CLOUDFRONT_ID=$CLOUDFRONT_ID" >> $GITHUB_ENV
        echo "DOMAIN_NAME=$DOMAIN_NAME" >> $GITHUB_ENV
        echo "FINGERPRINT=${{ github.sha }}/${{ github.run_id }}/${{ github.run_number}}" >> $GITHUB_ENV

    # Re-configure with the blog-specific role
    - name: Configure blog AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ env.BLOG_ROLE_ARN }}
        aws-region: us-east-2
    
    # Test AWS CLI availability
    - name: Test AWS CLI
      run: |
        which aws
        aws --version
        aws sts get-caller-identity

    # Install Hugo
    - name: Setup Hugo
      uses: peaceiris/actions-hugo@v2
      with:
        hugo-version: '0.128.0'
        extended: true
    
    # Build site with commit hash
    - name: Build site with commit hash
      run: |
        pwd
        # Add commit hash to hfingerprint file
        echo "${{ env.FINGERPRINT }}" > content/version/fingerprint.txt
        cat content/version/fingerprint.txt

        ls -lat .

        # Build site, omitting drafts/future for releases
        if [[ "${{ github.event_name }}" == "release" ]]; then
          hugo --minify
        else
          hugo --minify --buildDrafts --buildFuture
        fi
    
    # Pre-cache current index
    - name: Pre-cache current index
      run: curl -s https://${{ env.DOMAIN_NAME }}/version/fingerprint.txt > /dev/null || true

    # Deploy to S3
    - name: Deploy to S3
      run: aws s3 sync ./public/ s3://${{ env.BLOG_BUCKET }}/ --delete

    # Verify S3 deployment
    - name: Verify S3 deployment
      run: |
        S3_FINGERPRINT=$(aws s3 cp s3://${{ env.BLOG_BUCKET }}/version/fingerprint.txt -)
        if [ "$S3_FINGERPRINT" != "${{ env.FINGERPRINT }}" ]; then
          echo "S3 deployment failed - fingerprint mismatch: expected ${{ env.FINGERPRINT }}, got $S3_FINGERPRINT"
          exit 1
        fi
        echo "S3 deployment verified - fingerprint matches"

    # Invalidate CloudFront
    - name: Invalidate CloudFront
      run: |
        INVALIDATION_ID=$(aws cloudfront create-invalidation --distribution-id ${{ env.CLOUDFRONT_ID }} --paths "/*" --query 'Invalidation.Id' --output text)
        echo "CloudFront invalidation created: $INVALIDATION_ID"

    # Verify deployment
    - name: Verify deployment
      run: |
        echo "Waiting 30 seconds for CloudFront invalidation..."
        sleep 30
        DEPLOYED_FINGERPRINT=$(curl -s https://${{ env.DOMAIN_NAME }}/version/fingerprint.txt)
        if [ "$DEPLOYED_FINGERPRINT" != "${{ env.FINGERPRINT }}" ]; then
          echo "Deployment verification failed - fingerprint mismatch: expected ${{ env.FINGERPRINT }}, got $DEPLOYED_FINGERPRINT"
          exit 1
        fi
        echo "Deployment verified successfully - site is live with new content"
